<html>
<body>
<pre>
          Short
Binary search  
#include<stdio.h>

int main() {
    int i, n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int a[n]; 
    printf("Enter the array elements: ");
    for(i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    printf("Original array elements: ");
    for(i = 0; i < n; i++) {
        printf("%d  ", a[i]);
    }

    int target;
    printf("\nEnter the target value: ");
    scanf("%d", &target);

    int s = 0, e = n - 1;
    int found = 0;

    while (s <= e) {
        int mid = (s + e) / 2;

        if (a[mid] == target) {
            printf("Element found at index: %d\n", mid);
            found = 1;  
            break;  
        } else if (a[mid] < target) {
            s = mid + 1;  
        } else {
            e = mid - 1;  
        }
    }

    if (!found) {
        printf("Element not found in the array\n");
    }

    return 0;
}
Minmax
#include<stdio.h>
int main(){
int i,j,n;
printf("Enter the size of array : ");
scanf("%d",&n);
int a[n];
printf("Enter the array elements");
for(i=0; i<n; i++)
{
scanf("%d",&a[i]);

}

int min =a[0];
int max=a[0];
for(j=0; j<n; j++)
{
	 if(min>a[j])
	 {
	 	 min=a[j];
	 }
	 
	 if(max<a[j])
	 {
	 	 max=a[j];
	 }
	 
	 
}

printf("The max ele : %d",max);
printf("\n The min ele : %d",min);


}
0/1 knapsack
#include <stdio.h>

int max(int a, int b) {
    return (a > b) ? a : b;
}

int knapsack(int capacity, int weights[], int values[], int n) {
    int dp[n + 1][capacity + 1];
    int i, w;

    for (i = 0; i <= n; i++) {
        for (w = 0; w <= capacity; w++) {
            if (i == 0 || w == 0) {
                dp[i][w] = 0;
            } else if (weights[i - 1] <= w) {
                dp[i][w] = max(values[i - 1] + dp[i - 1][w - weights[i - 1]], dp[i - 1][w]);
            } else {
                dp[i][w] = dp[i - 1][w];
            }
        }
    }

    return dp[n][capacity];
}

int main() {
    int capacity;
    int n;
    int i;

    printf("Enter the knapsack capacity: ");
    scanf("%d", &capacity);

    printf("Enter the number of items: ");
    scanf("%d", &n);

    int weights[n];
    int values[n];

    printf("Enter the weights of the items: ");
    for (i = 0; i < n; i++) {
        scanf("%d", &weights[i]);
    }

    printf("Enter the values of the items: ");
    for (i = 0; i < n; i++) {
        scanf("%d", &values[i]);
    }

    int max_value = knapsack(capacity, weights, values, n);

    printf("Maximum value in the knapsack: %d\n", max_value);

    return 0;
}
N-queen
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>


void printBoard(int board[], int n)
 {
 	 int i, j;
    for ( i = 0; i < n; i++) {
        for ( j = 0; j < n; j++) {
            if (board[i] == j) {
                printf("Q ");  
            } else {
                printf(". "); 
            }
        }
        printf("\n");
    }
    printf("\n");
}


bool isSafe(int board[], int row, int col) {
	int i;
    for (i = 0; i < row; i++) {
    
        if (board[i] == col || abs(board[i] - col) == (row - i)) {
            return false;  
        }
    }
    return true;  
}

bool solveNQueens(int board[], int row, int n) {
    if (row == n) {  
        printBoard(board, n);  
        return true;  
    }

    bool foundSolution = false;  
    int col;
    for ( col = 0; col < n; col++) {
        if (isSafe(board, row, col)) {
            board[row] = col;  
            
            foundSolution |= solveNQueens(board, row + 1, n);
        }
    }
    return foundSolution;
}

int main() {
    int n;
    printf("Enter the number of queens: ");
    scanf("%d", &n);

    int* board = (int*)malloc(n * sizeof(int)); 
    bool hasSolution = solveNQueens(board, 0, n);  

    if (!hasSolution) {
        printf("No solution found for %d queens.\n", n);
    }

    free(board); 
    return 0;
}
             
LONG
Merge sort
#include<stdio.h>
int main()
 {
    int i, n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int a[n]; 
    printf("Enter the array elements: ");
    for(i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    printf("Original array elements: ");
    for(i = 0; i < n; i++) {
        printf("%d  ", a[i]);
    }



      mergesort(a,0,n);
   printf("After sorting  array elements: ");
    for(i = 0; i < n; i++) {
        printf("%d  ", a[i]);
    }

}

 int[]  mergesort(int[] a,int s, int size)
    {
    	  int e=size-1; 
    	  
    	   if(s<e)
    	   {
    	
    	  int mid = (s+e)/2;
    	  mergesort(a,s,mid);
    	  mergesort(a,mid+1,e);
    	  merge(a,s,m,e);  	   
	}
		   
		    
	}


    int[] merge(int[] a, int s, int e, int e)
    {
    	 
    	 
    	 
	}



Quick sort
#include<stdio.h>
int main()
 {
    int i, n;
    printf("Enter the size of the array: ");
    scanf("%d", &n);

    int a[n]; 
    printf("Enter the array elements: ");
    for(i = 0; i < n; i++) {
        scanf("%d", &a[i]);
    }

    printf("Original array elements: ");
    for(i = 0; i < n; i++) {
        printf("%d  ", a[i]);
    }



      mergesort(a,0,n);
   printf("After sorting  array elements: ");
    for(i = 0; i < n; i++) {
        printf("%d  ", a[i]);
    }

}

 int[]  mergesort(int[] a,int s, int size)
    {
    	  int e=size-1; 
    	  
    	   if(s<e)
    	   {
    	
    	  int mid = (s+e)/2;
    	  mergesort(a,s,mid);
    	  mergesort(a,mid+1,e);
    	  merge(a,s,m,e);  	   
	}
		   
		    
	}


    int[] merge(int[] a, int s, int e, int e)
    {
    	 
    	 
    	 
	}



Strassen
#include <stdio.h>

void strassenMultiply(int A[][2], int B[][2], int C[][2]) {
    int M1, M2, M3, M4, M5, M6, M7;

    M1 = (A[0][0] + A[1][1]) * (B[0][0] + B[1][1]);
    M2 = (A[1][0] + A[1][1]) * B[0][0];
    M3 = A[0][0] * (B[0][1] - B[1][1]);
    M4 = A[1][1] * (B[1][0] - B[0][0]);
    M5 = (A[0][0] + A[0][1]) * B[1][1];
    M6 = (A[1][0] - A[0][0]) * (B[0][0] + B[0][1]);
    M7 = (A[0][1] - A[1][1]) * (B[1][0] + B[1][1]);

    C[0][0] = M1 + M4 - M5 + M7;
    C[0][1] = M3 + M5;
    C[1][0] = M2 + M4;
    C[1][1] = M1 - M2 + M3 + M6;
}

void printMatrix(int matrix[][2], int row, int col) {
	int i,j;
    for (i = 0; i < row; i++) {
        for (j = 0; j < col; j++) {
            printf("%d ", matrix[i][j]);
        }
        printf("\n");
    }
}

int main() {
	int i,j;
    int A[2][2], B[2][2], C[2][2];

    printf("Enter elements of Matrix A (2x2):\n");
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 2; j++) {
            scanf("%d", &A[i][j]);
        }
    }

    printf("Enter elements of Matrix B (2x2):\n");
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 2; j++) {
            scanf("%d", &B[i][j]);
        }
    }

    printf("\nMatrix A:\n");
    printMatrix(A, 2, 2);

    printf("\nMatrix B:\n");
    printMatrix(B, 2, 2);

    strassenMultiply(A, B, C);

    printf("\nResultant Matrix C:\n");
    printMatrix(C, 2, 2);

    return 0;
}
Job sequencing
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>

typedef struct Job {
    char id;
    int dead;
    int profit;
} Job;

int compare(const void* a, const void* b) {
    Job* temp1 = (Job*)a;
    Job* temp2 = (Job*)b;
    return temp2->profit - temp1->profit;
}

int min(int num1, int num2) {
    return num1 > num2 ? num2 : num1;
}

void printJobScheduling(Job arr[], int n) {
    qsort(arr, n, sizeof(Job), compare);

    int result[n];
    bool slot[n];
    
    int i, j;
    for (i = 0; i < n; i++) {
        slot[i] = false;
    }

    for (i = 0; i < n; i++) {
        int deadline = min(n, arr[i].dead);
        for (j = deadline - 1; j >= 0; j--) {
            if (!slot[j]) {
                result[j] = i;
                slot[j] = true;
                break;
            }
        }
    }

    printf("Maximum profit job sequence:\n");
    for (i = 0; i < n; i++) {
        if (slot[i]) {
            printf("%c ", arr[result[i]].id);
        }
    }
    printf("\n");
}

int main() {
    int n;
    printf("Enter the number of jobs: ");
    scanf("%d", &n);

    Job arr[n];
    
    int i;
    for (i = 0; i < n; i++) {
        printf("Enter details for job %d:\n", i + 1);
        printf("  Job ID: ");
        scanf(" %c", &arr[i].id);
        printf("  Deadline: ");
        scanf("%d", &arr[i].dead);
        printf("  Profit: ");
        scanf("%d", &arr[i].profit);
    }

    printJobScheduling(arr, n);

    return 0;
}
Single source shortest path(greedy)
#include <stdio.h>
#include <limits.h>

#define V 6 

int minDistance(int dist[], int sptSet[]) {
    int min = INT_MAX;
    int min_index = -1;
    int v; // Declare the loop variable outside

    for (v = 0; v < V; v++) {
        if (sptSet[v] == 0 && dist[v] <= min) {
            min = dist[v];
            min_index = v;
        }
    }

    return min_index;
}

void printSolution(int dist[]) {
    int i; // Declare the loop variable outside
    printf("Vertex   Distance from Source\n");
    for (i = 0; i < V; i++) {
        printf("%d \t\t %d\n", i, dist[i]);
    }
}

void dijkstra(int graph[V][V], int src) {
    int dist[V];
    int sptSet[V];
    int i; // Declare the loop variable outside
    int count; // Declare the loop variable outside

    for (i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        sptSet[i] = 0;
    }

    dist[src] = 0;

    for (count = 0; count < V - 1; count++) {
        int u = minDistance(dist, sptSet);
        sptSet[u] = 1;

        for (i = 0; i < V; i++) { // Use the same loop variable
            if (!sptSet[i] && graph[u][i] && dist[u] != INT_MAX && dist[u] + graph[u][i] < dist[i]) {
                dist[i] = dist[u] + graph[u][i];
            }
        }
    }

    printSolution(dist);
}

int main() {
    int graph[V][V] = {
        {0, 2, 0, 1, 0, 0},
        {2, 0, 3, 2, 0, 0},
        {0, 3, 0, 0, 1, 0},
        {1, 2, 0, 0, 4, 3},
        {0, 0, 1, 4, 0, 2},
        {0, 0, 0, 3, 2, 0}
    };

    int src = 0;

    dijkstra(graph, src);

    return 0;
}
Single source shortest path(dynamic)
#include <stdio.h>
#include <stdlib.h>

#define INF 99999

struct Edge {
    int src, dest, weight;
};
struct Graph {
    int V, E;
    struct Edge* edge;
};

void printSolution(int dist[], int n) {
	int i;
    printf("Vertex   Distance from Source\n");
    for ( i = 0; i < n; ++i)
        printf("%d \t\t %d\n", i, dist[i]);
}

void bellmanFord(struct Graph* graph, int src) {
    int V = graph->V;
    int E = graph->E;
    int dist[V];
    int i,j;
    for (i = 0; i < V; ++i)
        dist[i] = INF;
    dist[src] = 0;

    for ( i = 1; i <= V - 1; ++i) {
        for (j = 0; j < E; ++j) {
            int u = graph->edge[j].src;
            int v = graph->edge[j].dest;
            int weight = graph->edge[j].weight;
            if (dist[u] != INF && dist[u] + weight < dist[v])
                dist[v] = dist[u] + weight;
        }
    }
    for ( i = 0; i < E; ++i) {
        int u = graph->edge[i].src;
        int v = graph->edge[i].dest;
        int weight = graph->edge[i].weight;
        if (dist[u] != INF && dist[u] + weight < dist[v]) {
            printf("Graph contains negative weight cycle\n");
            return;
        }
    }
    printSolution(dist, V);
}

int main() {
    int V,i, E;
    printf("Enter the number of vertices: ");
    scanf("%d", &V);
    printf("Enter the number of edges: ");
    scanf("%d", &E);

    struct Graph* graph = (struct Graph*)malloc(sizeof(struct Graph));
    graph->V = V;
    graph->E = E;
    graph->edge = (struct Edge*)malloc(E * sizeof(struct Edge));
    printf("Enter the details of each edge (source, destination, weight):\n");
    for (i = 0; i < E; ++i) {
        printf("Edge %d: ", i + 1);
        scanf("%d %d %d", &graph->edge[i].src, &graph->edge[i].dest, &graph->edge[i].weight);
    }

    int src;
    printf("Enter the source vertex: ");
    scanf("%d", &src);
    bellmanFord(graph, src);
    free(graph->edge);
    free(graph);

    return 0;
}
Sum of subsets
#include <stdio.h>

void printSubset(int subset[], int subsetSize) {
    printf("{ ");
    int i;
    for (i = 0; i < subsetSize; i++) {
        printf("%d ", subset[i]);
    }
    printf("}\n");
}


void findSubsets(int set[], int subset[], int setSize, int subsetSize, int index, int targetSum) {
    int sum = 0;

    int i;
    for (i = 0; i < subsetSize; i++) {
        sum += subset[i];
    }

    
    if (sum == targetSum) {
        printSubset(subset, subsetSize);
    }

    
    if (index >= setSize) {
        return;
    }

    
    subset[subsetSize] = set[index];
    findSubsets(set, subset, setSize, subsetSize + 1, index + 1, targetSum);

    
    findSubsets(set, subset, setSize, subsetSize, index + 1, targetSum);
}

int main() {
    
    int set[] = {1, 2, 3, 4, 5};
    int setSize = sizeof(set) / sizeof(set[0]);

    
    int subset[setSize];


    int targetSum = 6;

    printf("Subsets with sum %d are:\n", targetSum);


    findSubsets(set, subset, setSize, 0, 0, targetSum);

    return 0;
}
Multistage graph
#include <stdio.h>
#include <limits.h>

#define V 6 

int minDistance(int dist[], int sptSet[]) {
    int min = INT_MAX;
    int min_index = -1;
    int v;  // Declared outside the for-loop
    for (v = 0; v < V; v++) {
        if (sptSet[v] == 0 && dist[v] <= min) {
            min = dist[v];
            min_index = v;
        }
    }
    return min_index;
}

void printSolution(int dist[]) {
    int i;  // Declared outside the for-loop
    printf("Vertex   Distance from Source\n");
    for (i = 0; i < V; i++) {
        printf("%d \t\t %d\n", i, dist[i]);
    }
}

void dijkstra(int graph[V][V], int src) {
    int dist[V]; 
    int sptSet[V];
    int i;  // Declared outside the for-loop
    int u;  // Declared outside the for-loop
    int count;  // Declared outside the for-loop
    
    for (i = 0; i < V; i++) {
        dist[i] = INT_MAX;
        sptSet[i] = 0;
    }

    dist[src] = 0;

    for (count = 0; count < V - 1; count++) {
        u = minDistance(dist, sptSet);
        sptSet[u] = 1;

        for (i = 0; i < V; i++) {  // Reuse declared variable
            if (!sptSet[i] && graph[u][i] && dist[u] != INT_MAX && dist[u] + graph[u][i] < dist[i]) {
                dist[i] = dist[u] + graph[u][i];
            }
        }
    }

    printSolution(dist);
}

int main() {
    int graph[V][V] = {
        {0, 2, 0, 1, 0, 0},
        {2, 0, 3, 2, 0, 0},
        {0, 3, 0, 0, 1, 0},
        {1, 2, 0, 0, 4, 3},
        {0, 0, 1, 4, 0, 2},
        {0, 0, 0, 3, 2, 0}
    };
    
    int src = 0;

    dijkstra(graph, src);

    return 0;
}
All pairs shortest path
#include <stdio.h>

#define V 4
#define INF 99999

void printSolution(int dist[][V]) {
    printf("Shortest distances between every pair of vertices:\n");
    int i,j;
    for ( i = 0; i < V; i++) {
        for ( j = 0; j < V; j++) {
            if (dist[i][j] == INF)
                printf("%7s", "INF");
            else
                printf("%7d", dist[i][j]);
        }
        printf("\n");
    }
}

void floydWarshall(int dist[][V]) {
    int i, j, k;
    for (k = 0; k < V; k++) {
        for (i = 0; i < V; i++) {
            for (j = 0; j < V; j++) {
                if (dist[i][k] + dist[k][j] < dist[i][j])
                    dist[i][j] = dist[i][k] + dist[k][j];
            }
        }
    }
    printSolution(dist);
}

int main() {
    int graph[V][V] = { { 0, 5, INF, 10 },
                        { INF, 0, 3, INF },
                        { INF, INF, 0, 1 },
                        { INF, INF, INF, 0 } };

    floydWarshall(graph);

    return 0;
}
Implement OBST
#include <stdio.h>
#include <limits.h>

int sum(int freq[], int i, int j) {
    int s = 0;
    int k;
    for (k = i; k <= j; k++) {
        s += freq[k];
    }
    return s;
}

int optimalCost(int keys[], int freq[], int n) {
    int cost[n][n];
    int i;

    // Initialize the cost table
    for (i = 0; i < n; i++) {
        cost[i][i] = freq[i];
    }

    int length, j, r;

    // Fill the cost table for all subarray lengths
    for (length = 2; length <= n; length++) {
        for (i = 0; i <= n - length; i++) {
            j = i + length - 1;
            cost[i][j] = INT_MAX;

            for (r = i; r <= j; r++) {
                int leftCost = (r > i) ? cost[i][r - 1] : 0;
                int rightCost = (r < j) ? cost[r + 1][j] : 0;
                int c = leftCost + rightCost + sum(freq, i, j);

                if (c < cost[i][j]) {
                    cost[i][j] = c;
                }
            }
        }
    }

    return cost[0][n - 1];
}

int main() {
    int n;
    printf("Enter the number of keys: ");
    scanf("%d", &n);

    int keys[n];
    int freq[n];

    int i;

    printf("Enter the keys: \n");
    for (i = 0; i < n; i++) {
        scanf("%d", &keys[i]);
    }

    printf("Enter the frequencies: \n");
    for (i = 0; i < n; i++) {
        scanf("%d", &freq[i]);
    }

    int optimal_cost = optimalCost(keys, freq, n);

    printf("The optimal cost for the given keys is: %d\n", optimal_cost);

    return 0;
}








</pre>
</body>
</html>
